# Design: Enhance Extensibility Ecosystem

## Context

현재 workflow 엔진은 기본적인 플러그인 시스템을 가지고 있지만, 오픈소스 생태계로 성장하기 위해서는 개발자가 쉽게 노드를 개발하고 배포할 수 있는 인프라가 필요합니다. n8n, KNIME, Apache Airflow 등의 성공적인 워크플로우 플랫폼들은 모두 강력한 확장성과 커뮤니티 생태계를 가지고 있습니다.

## Goals

1. **Zero-to-Node in 5 minutes**: 개발자가 5분 안에 첫 번째 노드를 만들고 실행할 수 있어야 합니다
2. **Automatic Discovery**: 플러그인을 수동으로 등록하지 않고 자동으로 발견하고 로드해야 합니다
3. **Standard Packaging**: npm 패키지로 배포 가능한 표준 플러그인 구조를 제공해야 합니다
4. **Developer Experience**: 노드 개발을 위한 완전한 도구 체인을 제공해야 합니다
5. **Community Ready**: 커뮤니티가 쉽게 기여하고 배포할 수 있는 인프라를 제공해야 합니다

## Non-Goals

- 완전한 GUI 에디터 (별도 제안 필요)
- 클라우드 기반 플러그인 마켓플레이스 (초기 단계에서는 npm 기반)
- 플러그인 버전 자동 마이그레이션 (수동 마이그레이션 가이드 제공)

## Decisions

### Decision 1: CLI 패키지 구조

**선택**: 모노레포 내 별도 패키지로 `@workflow/cli` 생성

**이유**:
- CLI 도구는 별도 패키지로 분리하여 독립적으로 버전 관리 가능
- 사용자는 CLI만 설치하여 사용 가능 (전체 엔진 불필요)
- n8n의 `@n8n/node-cli` 패턴 참고

**대안 고려**:
- 단일 패키지 내 CLI 포함: 의존성 증가, 불필요한 코드 포함
- 외부 독립 패키지: 초기 단계에서는 모노레포 관리가 더 효율적

### Decision 2: 플러그인 발견 메커니즘

**선택**: `package.json`의 `keywords` 필드와 커스텀 필드 조합

**이유**:
- npm 생태계와 자연스럽게 통합
- 기존 npm 검색 기능 활용 가능
- 표준을 따르므로 도구 호환성 좋음

**구현**:
```json
{
  "name": "@workflow/nodes-my-plugin",
  "keywords": ["workflow", "workflow-plugin"],
  "workflow": {
    "plugin": true,
    "nodeTypes": ["my-node-1", "my-node-2"]
  }
}
```

**대안 고려**:
- 별도 레지스트리 서버: 초기 단계에서 과도한 복잡도
- 파일 시스템 기반: npm 패키지와 통합 어려움

### Decision 3: 플러그인 패키지 구조

**선택**: 표준 디렉토리 구조 강제

**구조**:
```
my-plugin/
├── package.json
├── src/
│   ├── nodes/
│   │   ├── MyNode1.ts
│   │   └── MyNode2.ts
│   └── index.ts
├── schemas/
│   └── my-node1-schema.json
└── icons/
    └── my-node1.svg
```

**이유**:
- 일관성 있는 구조로 자동 로딩 가능
- 개발자들이 쉽게 이해하고 따를 수 있음
- 도구가 자동으로 메타데이터 추출 가능

### Decision 4: 핫 리로딩 전략

**선택**: 파일 시스템 감시 + 플러그인 재등록

**이유**:
- 개발 중 빠른 피드백 루프 제공
- 전체 애플리케이션 재시작 불필요
- 개발자 경험 크게 향상

**구현**:
- `chokidar` 같은 파일 감시 라이브러리 사용
- 변경 감지 시 플러그인만 재등록
- 워크플로우 상태는 유지

### Decision 5: 테스트 유틸리티

**선택**: Jest 기반 테스트 헬퍼 제공

**이유**:
- 프로젝트가 이미 Jest 사용 중
- 노드 실행 컨텍스트 모킹 용이
- 통합 테스트 작성 간편

**제공 기능**:
- 노드 실행 시뮬레이션
- 입력 데이터 모킹
- 출력 검증 헬퍼
- 프로토콜 준수 검증

## Risks / Trade-offs

### Risk 1: 플러그인 자동 발견의 성능

**위험**: 많은 npm 패키지를 스캔하면 느려질 수 있음

**완화**:
- 캐싱 메커니즘 도입
- 지연 로딩 (lazy loading) 지원
- 사용자가 명시적으로 활성화한 플러그인만 로드

### Risk 2: 패키지 구조 변경의 하위 호환성

**위험**: 기존 플러그인이 새로운 구조를 따르지 않을 수 있음

**완화**:
- 마이그레이션 가이드 제공
- 레거시 구조도 지원 (deprecated)
- 자동 마이그레이션 스크립트 제공

### Risk 3: CLI 도구의 복잡도

**위험**: CLI가 너무 많은 기능을 포함하여 유지보수 어려움

**완화**:
- 플러그인 가능한 아키텍처
- 핵심 기능만 포함, 확장은 플러그인으로
- 명확한 명령어 구조

## Migration Plan

### Phase 1: CLI 및 개발 도구 (우선순위 높음)
1. `@workflow/cli` 패키지 생성
2. 노드 생성 명령어 구현
3. 기본 템플릿 제공
4. 테스트 유틸리티 추가

### Phase 2: 플러그인 발견 시스템
1. npm 패키지 스캐너 구현
2. 로컬 디렉토리 스캐너 구현
3. 자동 등록 메커니즘 통합
4. 캐싱 메커니즘 추가

### Phase 3: 패키징 표준
1. 패키지 구조 표준 문서화
2. 검증 도구 구현
3. 빌드 도구 통합
4. 배포 가이드 작성

### Phase 4: 커뮤니티 인프라
1. 플러그인 검색 명령어
2. 설치/제거 명령어
3. 메타데이터 확장
4. 문서화 완성

### Rollback Plan
- 각 단계는 독립적으로 롤백 가능
- 레거시 플러그인 등록 방식 유지
- 점진적 마이그레이션 지원

## Open Questions

1. **플러그인 버전 충돌**: 같은 노드 타입의 다른 버전을 어떻게 처리할까?
   - 현재: 최신 버전만 사용
   - 고려: 버전별 네임스페이스 지원?

2. **플러그인 샌드박싱**: 보안을 위해 플러그인을 샌드박스에서 실행해야 할까?
   - 초기: 신뢰 기반
   - 향후: 옵션으로 샌드박스 모드 제공

3. **플러그인 의존성 해결**: 복잡한 의존성 그래프를 어떻게 처리할까?
   - 현재: 단순 의존성 체크
   - 향후: 의존성 해결 엔진 필요

